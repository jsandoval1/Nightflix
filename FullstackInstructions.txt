Create a MERN Fullstack app:


1- Create Folder (projectName):

    1A- Create Folder for Server

        1B- This folder should contain
        *
            (Server(Folder))
            -------------
            (>) config
            (>) controllers
            (>) models 
            (>) routes
            (*) .env
            (JS) server.js
        *
            server - This is your backend server / project folder and will hold all server related files
                config - will handle the database configuration and connection
                controllers - will hold all logic for each model (i.e creating, updating, etc...)
                models - will hold all the schemas
                routes - will handle all of our routes for each model
                .env - will store our secret keys
                server.js - will handle all the server logic with express

2- After setting up folders...

    2A- Once you have created the server.js file and the folders

        2B- Open a new terminal window and navigate into your project folder (labeled as server in the image above) 

            2C- Install the server dependencies by running:
                *
                    npm init -y
                    -----------
                        if succesful should look like:
                            $  npm init -y
                                Wrote to C:\Users\19783\OneDrive\Desktop\CodingDojo\Javascript\Mern\Mongoose\HelloMongoose\package.json:

                                {
                                "name": "hellomongoose",
                                "version": "1.0.0",
                                "description": "",
                                "main": "server.js",
                                "scripts": {
                                    "test": "echo \"Error: no test specified\" && exit 1",
                                    "start": "node server.js"
                                },
                                "keywords": [],
                                "author": "",
                                "license": "ISC"
                                }
                
                NEXT:
                    npm install mongoose express dotenv
                    -----------------------------------
                        if succesful should look like:
                            $ npm install mongoose express dotenv
                                added 83 packages, and audited 84 packages in 2m

                                10 packages are looking for funding
                                run `npm fund` for details

                                found 0 vulnerabilities

                *

3- Once those are succesful add these lines of code to these files...

    3A- server.js receives (below near the top) => 

        require('dotenv').config();

            3B- Connecting to our Mongo Atlas account required us to pass a username and a password. 
                - For a larger application like this, we need a special place to put our secret information, and that place is a *.env* file!
                - NOTE: 
                - Require Mongoose
                - In any file that will use the Mongoose library, you will need to be sure to require it at the top of the file similar to this => const mongoose = require('mongoose');

4- Connecting to MongoDB with Mongoose

    4A- In vs-code, navigate to the config folder where you will need to create the mongoose.config.js file. 
        - This is where we use Mongoose to connect to our database. Before we begin, we need our connection string from Mongo Atlas. 

        4B- Navigate to your Atlas account and connect to your cluster.
            -https://cloud.mongodb.com/
                4B2- Sign In, make sure IP Address is working
                4B3- Leave >Overview and click into > Depolyment > Database
                4B4- Click connect via Drivers
                4B5- This will give us a connection string we can use to connect to the Atlas cluster we set up earlier!
                    * should look similar to: 
                    mongodb+srv://jcsandoval978:<password>@cluster0.pwonuoz.mongodb.net/?retryWrites=true&w=majority&appName=AtlasApp
                    
        4C- Using this connection string, let's finally give update mongoose.config.js: 
                *mongoose.config.js*
                    const mongoose = require('mongoose');
                    const dbName = process.env.DB;
                    const username = process.env.ATLAS_USERNAME;
                    const pw = process.env.ATLAS_PASSWORD;
                    const uri = `mongodb+srv://${username}:${pw}@YOUR_CONNECTION_STRING_HERE/${dbName}?retryWrites=true&w=majority`;
                    mongoose.connect(uri)
                        .then(() => console.log("Established a connection to the database"))
                        .catch(err => console.log("Something went wrong when connecting to the database", err));

                        NOTE:
                        *** WHAT NEEDS TO BE INSERTED ***
                        // mongodb+srv://jcsandoval978:<password> ***@cluster0.pwonuoz.mongodb.net*** /?retryWrites=true&w=majority&appName=AtlasApp

        
        4D- We will also need the username and password we set up for our Atlas account. 
            -However, it is not secure for us to just write the password openly into our code for potentially the whole world to see! 
            - That's why we created a .env file earlier, to store some of our private information. Let's update our .env file now!
                *.env*
                    PORT=8000
                    DB=my_db
                    # mongo atlas connection
                    ATLAS_USERNAME=YOUR_ATLAS_USERNAME # (Insert your info)
                    ATLAS_PASSWORD=YOUR_ATLAS_PASSWORD # (Insert your info)
            - Using this convention, update your username and password to match the information you created in your Atlas security settings. 
            - Remember this isn't your account username, but the one you made for your security group!

5-Create your Mongoose Schema and Model
    - Mongoose provides more structure to MongoDB by adding schemas that we can create that turn into models for our collections. 
    - These models specify keys, types, and even validations for documents in a specific collection. 
    - Mongoose also handles appropriate naming for us when it communicates with MongoDB!
    
    5A- In vs-code, make your way to the models folder and create the user.model.js file in the models folder where we create a User collection using mongoose. 
        - Remember, we need to import mongoose using the require statement at the top of the file.
            *user.model.js*
            ---------------
                const mongoose = require('mongoose');
                const UserSchema = new mongoose.Schema({
                    name: {
                        type: String
                    },
                    age: {
                        type: Number
                    }
                });
                
                const User = mongoose.model('User', UserSchema);
                ------------------------------------------------

                CHEAT SHEET FOR MONGOOSE PROPERTIES:
                ------------------------------------
                const mongoose = require('mongoose');
                const AuthorSchema = new mongoose.Schema({
                    name: {
                        type: String,
                        minlength: 3, // Use "minlength" for minimum length
                        required: true,
                    },
                    age: {
                        type: Number,
                        min: 18, // Use "min" for minimum numeric value
                    },
                    birthdate: {
                        type: Date,
                    },
                    isPublished: {
                        type: Boolean,
                        default: false, // Set a default value
                    },
                    genres: {
                        type: [String], // Array of strings
                    },
                    books: {
                        type: [mongoose.Schema.Types.ObjectId],
                        ref: 'Book', // Reference to another collection
                    },
                });

                const Author = mongoose.model('Author', AuthorSchema);
                
                module.exports = User;
                ----------------------------------------------------------

        - Let's break it down. 
        - The mongoose.model() method is the most important in this case. 
        - Its job is to take a blueprint object and, in turn, create the necessary database collection out of the model. 
        - We get this blueprint by making a new schema instance from the mongoose.Schema() object constructor. 
        - Notice how the mongoose.Schema() method takes an object as its parameter? 
        - The structure of that object is how each new document put into the collection will be formatted. 
            You can learn more about the other Schema Types here: http://mongoosejs.com/docs/schematypes.html

            - We then create a User variable to export and set it to the returned value of the mongoose.model() function: 
                a model object is created using the singular version of the collection name ('User') and the mongoose schema (UserSchema). 
            - This model will be used to enable all our needed CRUD functionality. 
            - Exporting the User variable will allow us to import and use the User model in any file we choose.

            NOTE: 
            After we create our first document using this model, we will find a lowercase, plural version of the collection name in our database. In this case, "users"

6- Use the Mongoose Models to Create / Retrieve / Update / Destroy

    6A- Navigate your way into the controllers folder where you will create the 
        => user.controller.js file that will house all of our logic for creating, retrieving, updating, and deleting users. 
    - Notice at the top of the file, we do not have a require("mongoose") statement. 
    - Instead we have a require("../models/user.model") statement which is importing the User variable that we exported from the user.model.js file. 
    - In our controller file, we export different functions that perform the basic CRUD operations using our User model.

            *model.controller.js*
            --------------------
                const Model = require('../models/modelName.model'); // Replace "modelName" with your model name
                // READ ALL
                module.exports.findAll = (req, res) => {
                    Model.find()
                        .then((items) => {
                            res.json({ Items: items });
                        })
                        .catch((err) => {
                            res.json(err);
                        });
                }

                // READ ONE
                module.exports.findOne = (req, res) => {
                    Model.findOne({ _id: req.params.id })
                        .then((item) => {
                            res.json({ Item: item });
                        })
                        .catch((err) => {
                            res.json(err);
                        });
                }

                // CREATE ONE
                module.exports.createOne = (req, res) => {
                    Model.create(req.body)
                        .then((createdItem) => {
                            res.json({ Item: createdItem });
                        })
                        .catch((err) => {
                            res.json(err);
                        });
                }

                // UPDATE ONE
                module.exports.updateOne = (req, res) => {
                    Model.findOneAndUpdate(
                        { _id: req.params.id },
                        req.body,
                        { new: true, runValidators: true }
                    )
                        .then((updatedItem) => {
                            res.json({ Item: updatedItem });
                        })
                        .catch((err) => {
                            res.json(err);
                        });
                }

                // DELETE ONE
                module.exports.deleteOne = (req, res) => {
                    Model.deleteOne({ _id: req.params.id })
                        .then((result) => {
                            res.json({ result: result });
                        })
                        .catch((err) => {
                            res.json(err);
                        });
                }
                -------------------------------------------------------
            
            A couple key points:
            - User is a constructor function which can create new user objects and also has other methods that will talk to the database!
            - the .then() will only execute upon successfully inserting data in the database
            - the .catch() will execute only if there is an error

7- Routing
    7A- Navigate your way into the routes folder where you will create the 
        => user.routes.js file that will be responsible for all of our routes dealing with the user model. 
    - Notice at the top of the file, this time, we have a require("../controllers/user.controller") statement which is 
        importing everything we exported from the controller file.

            *user.routes.js*
            ----------------
            const UserController = require('../controllers/user.controller');
    
            module.exports = app => {
                app.get('/api/users', UserController.findAllUsers);
                app.get('/api/users/:id', UserController.findOneSingleUser);
                app.patch('/api/users/:id', UserController.updateExistingUser);
                app.post('/api/users', UserController.createNewUser);
                app.delete('/api/users/:id', UserController.deleteAnExistingUser);
            }
        
        NOTE: 
        The order of these routes matter! 
        - If you have a route that uses a wildcard (like :id) before a path with a specific name, the wildcard route will always run. 
        - Move specific routes to the top to ensure they are followed.
            - For example, if you wanted to create a get route with a specific path, it would have to go before your get route for a single document.
                The following would never make it to the allusers route because the :id route would also match the string allusers:
                    *incorrect format of route order*
                    const UserController = require('../controllers/user.controller');
                    module.exports = app => {
                        app.get('/api/users/:id', UserController.findOneSingleUser);
                        app.get('/api/users/allusers', UserController.findAllUsers);
                    }

8- Server
    8A- Last but not least is our server.js file. 
        Because we modularized our files from the start... 
        - This allows our server.js file to contain only a few lines of code
        - Allows us to be able to easily expand our app, and helps us keep organized. 
        Take a moment and look over the server.js file and familiarize yourself with what's happening.
            *server.js*
            -----------
                const express = require("express");
                const app = express();
                require("dotenv").config(); // Load environment variables from a .env file.
                const port = process.env.PORT; // Set the port to be used from the environment variables.


                require("./config/mongoose.config"); // Connect to the MongoDB database using Mongoose.

                app.use(express.json(), express.urlencoded({ extended: true }));// Configure middleware to parse JSON and URL-encoded data.

                const AllMyAuthorRoutes = require("./routes/author.routes"); // Import and configure the author routes module.
                AllMyAuthorRoutes(app);

                app.listen(port, () => console.log(`Listening on port: ${port}`)); // Start the Express app, listening on the specified port.

9- Running Server
    9A-  You can go ahead and run your server using Nodemon in your terminal using:
        * nodemon server.js * 

        NOTE: 
        - If you receive the following warning when running your server, you can safely ignore it:
        DeprecationWarning: Listening to events on the Db class has been deprecated and will be removed in the next major version

10- .gitignore
    10A- As a final step, let's create one more file in our server folder. 
    - This file will prevent us from accidently uploading things to Github that don't belong on Github! 
    - Inside your project folder, create a new file called .gitignore and update it to look like the example.
        *.gitignore*
            /node_modules
            .env

    CONGRATS! IT SHOULD RUN! 

11- Debug
    11A- If it didn't work make sure the following things are done:
        - Make sure your post data matches the data that you are inserting into the database (name and age)
        - Make sure that your form submits a post request to '/users'
        - Make sure mongoose is actually installed
        - Check the order of everything related to mongoose (require --> connect --> Schema --> Model --> route)
        - Use lots of console.log statements and follow the flow of data.
        - Remember to read your error messages, they are your biggest clues for diagnosing the issue!

BONUS:
Common Mongoose Commands
    - Here is a list and examples of some common Mongoose Commands you may need to use. These will be used in most Mongoose projects so make sure to practice them as much as you can.

Defining a User Schema
    const UserSchema = new mongoose.Schema({ // Create a Schema for Users
        name: { type: String },
        age: { type: Number }
    }, { timestamps: true })
    const User = mongoose.model('User', UserSchema); // create a constructor function for our model and store in variable 'User'

Finding all Users
    User.find() // ...retrieve an array of all documents in the User collection
        .then(users => {
            // logic with users results
        })
        .catch(err => res.json(err));

Finding all Users where their name is Jessica
    User.find({name:'Jessica'}) // ...retrieve an array of documents matching the query object criteria
        .then(usersNamedJessica => {
            // logic with usersNamedJessica results
        })
        .catch(err => res.json(err));

Finding one User by _id
    User.findOne({_id: '5d34d361db64c9267ed91f73'}) // ...retrieve 1 document (the first record found) matching the query object criteria
        .then(user => {
            // logic with single user object result
        })
        .catch(err => res.json(err));

Create a user
    // ...create a new document to store in the User collection and save it to the DB.
    const bob = new User(req.body); // req.body is an object containing all the users data.
    // if we look at req.body as an object literal it would look like this

        /*
        * req.body = {
        *		"name": "Bob Ross",
        *		"age": 42
        *	}
        **/
    bob.save()
        .then(newUser => {
            // logic with succesfully saved newUser object
        })
        .catch(err => res.json(err)); // If there's an error and the record was not saved, this (err) will contain validation errors.

Create a user (simplified)
    const { userData } = req.body; // ...create a new document to store in the User collection and save it to the DB.
    User.create(userData)
        .then(newUser => {
            // logic with succesfully saved newUser object
        })
        .catch(err => res.json(err)); // If there's an error and the record was not saved, this (err) will contain validation errors.

Delete one user // ...delete 1 document that matches the query object criteria
    User.remove({_id: '5d34d361db64c9267ed91f73'})
        .then(deletedUser => {
            // logic (if any) with successfully removed deletedUser object
        })
        .catch(err => res.json(err));

Update one record // ...update 1 document that matches the query object criteria
    User.updateOne({name:'Bob Ross'}, {
        name: 'Ross Bob',
        $push: {pets: {name: 'Sprinkles', type: 'Chubby Unicorn' }}
    })
        .then(result => {
            // logic with result -- note this will be the original object by default!
        })
        .catch(err => res.json(err));

Advanced Queries

    An alternative way to update a record
        User.findOne({name: 'Bob Ross'})
            .then(user => {
                user.name = 'Rob Boss';
                user.pets.push({name: 'Sprinkles', type: 'Chubby Unicorn'});
                return user.save();
            })
            .then(saveResult => res.json(saveResult))
            .catch(err => res.json(err));


    Validate for uniqueness before creating new DB entry
        User.exists({name: req.body.name})
            .then(userExists => {
                if (userExists) {
                    // Promise.reject() will activate the .catch() below.
                    return Promise.reject('Error Message Goes Here');
                }
                return User.create(req.body);
            })
            .then(saveResult => res.json(saveResult))
            .catch(err => res.json(err));


    For more resources on mongoose commands: http://mongoosejs.com/docs/index.html

Validations
    Validating new entries for Mongoose models is a breeze. 
    - Let's say, for our users we wanted to make the first name, last name, and the email required. 
    - We can add our validation in Mongoose Model like this:
        would go in *user.model.js*
            const mongoose = require("mongoose");
            const UserSchema = new mongoose.Schema(
            {
                first_name: {
                type: String,
                required: [true, "First name is required"],
                minlength: [6, "First name must be at least 6 characters long"]
                },
                last_name: {
                type: String,
                required: [true, "Last name is required"],
                maxlength: [20, "Last name must be at least 6 characters long"]
                },
                age: {
                type: Number,
                min: [1, "You must be at least 1 or older to register"],
                max: [150, "You must be at most 149 years old to register"]
                },
                email: { type: String, required: [true, "Email is required"] }
            },
            { timestamps: true }
            );

            const User = mongoose.model("User", UserSchema);

            module.exports = User;

Using Postman to Validate:
    Open Postman.

    CREATE:
    1- Set the HTTP method to POST.
    2- Enter the URL for your API endpoint: http://localhost:YOUR_PORT/api/YOUR_OBJ (replace YOUR_PORT with the actual port your server is running on)
    3- In the Body section, select the "raw" option, and enter the JSON data for your YOUR_OBJ. For example:
        {
        "jokeText": "Why did the chicken cross the road??",
        "punchline": "To get to the other side!"
        }

    GET ALL:
    1- Set the HTTP method to GET.
    2- Enter the URL for your API endpoint: http://localhost:YOUR_PORT/api/YOUR_OBJ (replace YOUR_PORT with the actual port your server is running on)
    3- In the Body section, select the "raw" option, and enter the JSON data for your YOUR_OBJ. For example:
        {
        "jokeText": "Why did the chicken cross the road??",
        "punchline": "To get to the other side!"
        }

    GET ONE:
    1- Open Postman.
    2- Create a new request.
    3- Set the HTTP method to GET.
    4- Enter the URL for your API endpoint by appending the ID of the YOUR_OBJ you want to retrieve. 
        For example, if you want to retrieve the YOUR_OBJ with the ID "YOUR_ID," your URL should look like this:
            http://localhost:YOUR_PORT/api/YOUR_OBJ/YOUR_ID (replace YOUR_PORT with the actual port your server is running on)
    5- Click the "Send" button to submit the GET request.

    PUT: 
    1- Open Postman.
    2- Create a new request.
    3- Set the HTTP method to PUT.
    4- Enter the URL for your API endpoint, including the ID of the resource you want to update.
        PUT http://localhost:YOUR_PORT/api/YOUR_OBJ/YOUR_ID (replace YOUR_PORT with the actual port your server is running on)
    5- In the Body section, select the "raw" option.
    6- Enter the JSON data for the updated resource. Include only the fields that you want to update. For example:
        {
        "jokeText": "Updated joke text",
        "punchline": "Updated punchline"
        }
    7- Click the "Send" button to submit the PUT request.

    DELETE (Delete One):
    Open Postman.
    Create a new request.
    Set the HTTP method to DELETE.
    Enter the URL for your API endpoint, including the ID of the resource you want to delete.
        DELETE http://localhost:YOUR_PORT/api/YOUR_OBJ/YOUR_ID
    Click the "Send" button to submit the DELETE request. (replace YOUR_PORT with the actual port your server is running on)
    This "DELETE" request will delete the resource with the specified ID. Make sure to replace YOUR_PORT, YOUR_OBJ, and YOUR_ID with the appropriate values for your specific API and resource.

ADDING THE FRONT END- AKA CLIENT Folder

1- Create Vite
    1A- Make sure you are in the same folder level as your "server.js".
        1B- RUN these lines in the terminal:

            1- *npm create vite@latest*
            ------------------------
                click on React, Javascript + SWG

                    2- *cd into client folder*
                    --------------------------
                    enter the folder

                        3- *npm install*
                        ----------------
                        install node modules

                            4- *npm run dev*
                            ----------------
                            make sure it runs by running localhost


Create React App...
    1A- Go to parent folder so you are equal level with server/ if you command *ls* ( I like to split termnials at this point)
        Run this in the terminal in the parent folder: 
        *npx create-react-app your-project-name-here*
        or for short for MERN
        *npx create-react-app client*

            1B- What next? 
            Enter: 
            cd client
            npm start

2- Install Axios (Applies for CRA as well)
    2A- run this line in the client terminal to add axios (SERVER CANNOT BE ACTIVE TO ADD)

        *npm install axios* 
        -------------------
        if succesful it should look like: 
            $ npm install axios

            added 9 packages, and audited 223 packages in 9s

            94 packages are looking for funding
            run `npm fund` for details

            found 0 vulnerabilities

                            if succesful (CRA):
                            -------------------
                            added 3 packages, and audited 1531 packages in 16s

                            245 packages are looking for funding
                            run `npm fund` for details

                            8 vulnerabilities (2 moderate, 6 high)

                            To address all issues (including breaking changes), run:
                            npm audit fix --force

                            Run `npm audit` for details.

3- Adding Cors-
    3A- At this point, you can start your server via nodemon server.js and your React app via npm run start in two different consoles. 
        - Once you have them both running, you should be able to visit 'localhost:3000'. 
        - So, let's stop your express server and install an extra package within your server. NOT THE CLIENT
        
        3B- Run this line in the terminal for the server:

            *npm install cors*
            ------------------
            if succesful should look like:
                $ npm install cors

                added 2 packages, and audited 87 packages in 7s

                10 packages are looking for funding
                run `npm fund` for details

                found 0 vulnerabilities
        
        -This will install the ability to make cross-origin requests. Now, we will need to change our server.js as the following:

            3C- Modify the server.js file to this: 
                const express = require('express');
                const cors = require('cors') // <=============This is new
                const app = express();
                require('dotenv').config();
                const port = process.env.PORT;
                    
                app.use(cors()) // <============= This is new 
                require('./routes/YOUR_OBJ.routes')(app);
                app.listen(port, () => console.log(`Listening on port: ${port}`) );

4- server/ server.js gets a few updates...

    4A- Make these changes to server.js:

        *server.js*
        -----------
            const express = require("express");
            const cors = require('cors') //! <=============This is new
            const app = express();

            require("dotenv").config(); // Load environment variables from a .env file.
            const port = process.env.PORT; // Set the port to be used from the environment variables.

            require("./config/mongoose.config"); // Connect to the MongoDB database using Mongoose.
            app.use(cors()) //! <============= This is new 
            app.use(express.json(), express.urlencoded({ extended: true }));// Configure middleware to parse JSON and URL-encoded data.

            const AllMyAuthorRoutes = require("./routes/author.routes"); // Import and configure the author routes module.
            AllMyAuthorRoutes(app);

            app.listen(port, () => console.log(`Listening on port: ${port}`)); // Start the Express app, listening on the specified port.

5- Setting up Views and Components in client...

    5A- Within the src folder, let's add two more folders: views and components. 
            *cd src/
            *mkdir views components
            *cd ..

        5A2- Lets also install:

        *npm install react-router-dom* 
            in the client

        AND ALTER:

        *index.js*
        ----------
                import React from 'react';
                import ReactDOM from 'react-dom/client';
                import './index.css';
                import App from './App';
                // import reportWebVitals from './reportWebVitals';
                import { BrowserRouter } from 'react-router-dom';
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                    <React.StrictMode>
                        <BrowserRouter>
                            <App />
                        </BrowserRouter>
                    </React.StrictMode>
                );


Views Examples:

    *Main.js* containing a form and list 
    ---------
    import React, { useEffect, useState } from 'react';
    import axios from 'axios';
    import AuthorForm from '../components/AuthorForm';
    import AuthorList from '../components/AuthorList';

    const Main = (props) => {
        const [authors, setAuthors] = useState([]); // Store the list of authors
        const [loaded, setLoaded] = useState(false); // Indicates whether data has been loader not

        // useEffect to fetch author data from the API
        useEffect(() => {
            axios.get('http://localhost:8000/api/authors')
                .then((res) => {
                    setAuthors(res.data.Authors); // Update the 'authors' state with the fetched data
                    setLoaded(true); // Sets loaded
                })
                .catch((err) => console.error(err));
        }, []);

        // Define a function to add a new author to the list
        const addAuthor = (newAuthor) => {
            setAuthors([...authors, newAuthor]); // Update the 'authors' state by adding the new author to the list
        };

        return (
            <div>
                <AuthorForm onAuthorAdded={addAuthor} /> {/* Render the author form and pass 'addAuthor' function as a prop so (child) form can invoke it */}
                <hr />
                {loaded ? <AuthorList authors={authors} /> : null} {/* Render the author list if data is loaded, passing [authors] as a prop to the list (child) component */}
            </div>
        );
    };

    export default Main;

    ---------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------


Components Examples...

    *AuthorForm.js*
    ---------------
    // Import necessary modules
    import React, { useState } from 'react';
    import axios from 'axios';

    const AuthorForm = ({ onAuthorAdded }) => {
        const [name, setName] = useState(""); // Set up state variables to store the author's name

        const onSubmitHandler = (e) => {
            e.preventDefault();

            // POST request to the API to create a new author
            axios .post('http://localhost:8000/api/authors', {name}) // Include the author's name in the request
                .then((res) => {
                    const newAuthor = res.data.Author; // Extract the newly created author data from the response
                    onAuthorAdded(newAuthor); // Call the 'onAuthorAdded' function passed as a prop to update the author list in the Main component
                    setName(""); // Clear the input field by setting the 'name' state to an empty string
                })
                .catch((err) => console.log(err));
        };

        return (
            <form onSubmit={onSubmitHandler}>
                <p>
                    <label>Author Name</label><br />
                    <input
                        type="text"
                        onChange={(e) => setName(e.target.value)}
                        value={name}
                    />
                </p>
                <input type="submit" />
            </form>
        );
    };

    export default AuthorForm;
    ---------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------

    *AuthorList.js*
    --------------
    import React from 'react';

    const AuthorList = (props) => {
        return (
            <div>
                {props.authors.map((author, i) => (// 'props.authors' is an array of author objects passed as a prop
                    <p key={i}> {author.name} </p> // 'author.name' is accessed to show the author's name
                ))}
            </div>
        );
    };

    export default AuthorList;
    ---------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------














